#### algorithm 算法
```
优质博客文章：Java数据结构和算法系列
http://www.cnblogs.com/ysocean/tag/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/

算法：
  1.排序算法：
    时间复杂度O(n2)：冒泡排序、选择排序、直接插入排序
    
    三种算法的比较（比较次数、交换次数、随机还是基本有序）
    
    冒泡排序：没有额外空间占用
      思路：比较相邻的元素。如果第一个比第二个大，就交换他们两个。
      循环N-1次后，最后一个元素就是最大值，重复循环比较，除了最后一个。
      
      分析：冒泡排序是由两个for循环构成，第一个for循环的变量 i 表示总共需要多少轮比较，
      第二个for循环的变量 j 表示每轮参与比较的元素下标【0,1，......，length-i】，
      因为每轮比较都会出现一个最大值放在最右边，所以每轮比较后的元素个数都会少一个，
      这也是为什么 j 的范围是逐渐减小的。
      
      优化：如果已经有序，可以提前结束循环
      
      性能：（N-1）+（N-2）+...+1 = N*（N-1）/2
      冒泡排序运行需要 O(N2) 时间级别。
      
    选择排序：没有额外空间占用
      思路：每一次从待排序的数据元素中选出最小的一个元素，
      存放在序列的起始位置，直到全部待排序的数据元素排完。
      
      分析：比较简单，N-1轮循环，每次比较i+1到最后的元素，有小的就替换
      
      性能：N*（N-1）/2
      选择排序用大O表示是O(N2) 时间级别。
      
    直接插入排序：没有额外空间占用  
      【插入排序还分为直接插入排序、二分插入排序、链表插入排序、希尔排序。】
      思路：每一步将一个待排序的记录，插入到前面已经排好序的有序序列中去，直到插完所有元素为止。
      
      性能：1+2+3+...+N-1 = N*（N-1）/2。
      用大O表示法大致需要需要 O(N2) 时间级别。
    
   
```